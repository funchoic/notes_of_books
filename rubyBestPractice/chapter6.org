* 第6章 うまくいかないとき デバッグの方法を知る
1.リアルなバグ取り 基本方針
2.バグ取りプロセスを磨くのに役立つ、具体的なツールやテクニック
** Rubyコードのデバッギングプロセス
- 1.与えられた機能に対して適用される、異なるシナリオをいくつか見つける
- 2.これらのシナリオのなかで、バグによって影響を受けているケースを特定して、分離する。
- 3.irbを立ち上げ、オブジェクト内部が実際にどうなるか見る。失敗するシナリオの問題の根本原因を掘り下げる。
- 4.問題を再現するためのテストと、問題が解決したときに期待していることを一緒に書く
- 5.テストをパスするよう修正
** 欠陥の本質をとらえる
たいていのバグはずっと下に隠れている。テストコードがたどる実行パスを頭の中で追跡する習慣が身についている。
- テストコードからはできるだけ無関係なコードを削除する。
- テストコードを自己記述的に。(初見の人がわかるようなコードに)
- 問題の根本原因に達するまでは、テストコードを見直す。それまでは高レベルのテストコードは捨てない。
- 根本原因がわかったら、「そのテストがとおればバグがなくなった」と証明するようなコードを書く

** コードを精査する
*** 出力の改良
構造化したデータを出力するときには、
: pp(pretty-print)
もしくは
: require "yaml"
: y object
をつかうと、きれいに出力される。

*** 干し草の中から針を見つける
大量のデータがあってテストが難しい場合、fakerライブラリをつかうとよい。
これをつかい
: data.select.with_index do |e,i|
:   begin
:     Integer(e[:payment]) > 1000
:   rescue ArgumentError
:     p [e,i]
:   end
: end
のようにすると、問題のあるレコードをすべて表示することができる。
こうやって、問題がなにかを絞っていく。

*** まとめ
自分でinspectメソッドを書くことで、Kernel#pとirbの出力をカスタマイズできる
yamlを利用すると、洗練されたKernel#yを使い、オブジェクトを構造化して出力できる。

** Loggerを使う
ログの出力をしてくれるライブラリ。
*** tips
StandardErrorクラスをつくることで、エラー時にraiseをなくすことができる
エラーの段階には、
通常のエラーをERROR
クラッシュするときのエラーをFATALとすると管理しやすい
*** まとめ
- エラーのロギングは、物理的にアウリケーションを常時監視することのできないような、長時間稼動するサーバプロセスに不可欠
- マルチプロセス環境で作業しているときは、ログファイルを必ずプロセス毎にわけるように。さもなければクラッシュしてしまう
- Loggerは強力であり、たくさんの機能がある。
- Rubyのコマンドライン出力に似たエラー報告をログに入れたければ、StandardError#reportのテンプレを見る
- エラーメッセージのロギングに関して、FATALは復旧する見込みのないようなバグを表すようにし、ERRORはもっと弱い制約につかう
* まとめ
Rubyのデバッギングプロセスは流動的になることがおおい。
実際にどのように動くのかをうまく記述することから始まり、修正が見つかるまでさまざまあ戦略を用いる。
コードにある問題を見つけるためにデバッガが必要というわけでないので、インストロペクション機能を使うようにする。

バグを追いかけているうちに見失ってしまったら、スローダウンして、本章でつかった戦略を活用する。
